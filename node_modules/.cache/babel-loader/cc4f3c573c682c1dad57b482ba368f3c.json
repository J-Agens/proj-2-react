{"ast":null,"code":"var _jsxFileName = \"/Users/Shadow/react1/myapp/src/components/SwapiQuery.tsx\";\nimport React from 'react';\nimport { getPlanet } from '../api/SwapiClient';\nexport class SwapiQuery extends React.Component {\n  //Our constructor is used by React before anything hits the actual DOM/page\n  // React manages something called the \"virtual DOM\" that it uses for optimizations\n  // React might recreate our components and modify this virtual DOM more or less times\n  // than we expect as it optimizes.  What this means is that the constructor, and any\n  // of our functions that use the virtual DOM should HAVE NO SIDE EFFECTS.\n  // The shorter punchline is, only send HTTP requests in two special methods on your components:\n  // componentDidMount() and componentDidUpdate()\n  constructor(props) {\n    super(props);\n\n    this.incrementPlanetId = () => {\n      this.setState({\n        planetId: this.state.userid + 1\n      });\n    };\n\n    this.state = {\n      swapiResponse: 'pending...',\n      userid: 1\n    };\n  }\n\n  async componentDidMount() {\n    //This runs after the component has added an element to the actual DOM for the first time.\n    // In other words, this runs once the component is done being created.\n    // Send requests here!\n    this.setState({\n      swapiResponse: await getPlanet(this.state.userid)\n    });\n  } // Lets us explicitly compare new state and new props to the current state and props\n  // Then decide if we need to update or not.\n  // We can use this to make our app more efficient and fix update->setState->update loops\n\n\n  shouldComponentUpdate(nextProps, nextState) {\n    // If this returns true, the component will update.  If false, the component won't.\n    // should update if we have different response from SWAPI, otherwise no.\n    return this.state.swapiResponse !== nextState.swapiResponse;\n  }\n\n  async componentDidUpdate() {\n    //This runs when the component updates on the actual DOM\n    this.setState({\n      swapiResponse: await getPlanet(this.state.userid)\n    });\n  } // We could send a request here too, that'd be OK.\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"button\", {\n      onClick: this.incrementPlanetId,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58,\n        columnNumber: 7\n      }\n    }, \"Next Planet\"), /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 7\n      }\n    }, \"Response from SWAPI for id \", this.state.planetId, \": \", JSON.stringify(this.state.swapiResponse)));\n  }\n\n}","map":{"version":3,"sources":["/Users/Shadow/react1/myapp/src/components/SwapiQuery.tsx"],"names":["React","getPlanet","SwapiQuery","Component","constructor","props","incrementPlanetId","setState","planetId","state","userid","swapiResponse","componentDidMount","shouldComponentUpdate","nextProps","nextState","componentDidUpdate","render","JSON","stringify"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,SAAT,QAA0B,oBAA1B;AAEA,OAAO,MAAMC,UAAN,SAAyBF,KAAK,CAACG,SAA/B,CAAmD;AAExD;AACA;AACA;AACA;AACA;AAEA;AACA;AACAC,EAAAA,WAAW,CAACC,KAAD,EAAa;AACtB,UAAMA,KAAN;;AADsB,SAkCxBC,iBAlCwB,GAkCJ,MAAM;AACxB,WAAKC,QAAL,CAAc;AACZC,QAAAA,QAAQ,EAAE,KAAKC,KAAL,CAAWC,MAAX,GAAoB;AADlB,OAAd;AAGD,KAtCuB;;AAEtB,SAAKD,KAAL,GAAa;AACXE,MAAAA,aAAa,EAAE,YADJ;AAEXD,MAAAA,MAAM,EAAE;AAFG,KAAb;AAID;;AAED,QAAME,iBAAN,GAA0B;AACxB;AACA;AACA;AACA,SAAKL,QAAL,CAAc;AACZI,MAAAA,aAAa,EAAE,MAAMV,SAAS,CAAC,KAAKQ,KAAL,CAAWC,MAAZ;AADlB,KAAd;AAGD,GAzBuD,CA2BxD;AACA;AACA;;;AACAG,EAAAA,qBAAqB,CAACC,SAAD,EAAiBC,SAAjB,EAAiC;AACpD;AACA;AACA,WAAO,KAAKN,KAAL,CAAWE,aAAX,KAA6BI,SAAS,CAACJ,aAA9C;AACD;;AAED,QAAMK,kBAAN,GAA2B;AACzB;AACA,SAAKT,QAAL,CAAc;AACZI,MAAAA,aAAa,EAAE,MAAMV,SAAS,CAAC,KAAKQ,KAAL,CAAWC,MAAZ;AADlB,KAAd;AAGD,GAzCuD,CA2CxD;;;AAOAO,EAAAA,MAAM,GAAG;AACP,wBACE,uDAEA;AAAQ,MAAA,OAAO,EAAE,KAAKX,iBAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAFA,eAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCAA+B,KAAKG,KAAL,CAAWD,QAA1C,QAAsDU,IAAI,CAACC,SAAL,CAAe,KAAKV,KAAL,CAAWE,aAA1B,CAAtD,CAJA,CADF;AAQD;;AA3DuD","sourcesContent":["import React from 'react';\nimport { getPlanet } from '../api/SwapiClient';\n\nexport class SwapiQuery extends React.Component<any, any> {\n\n  //Our constructor is used by React before anything hits the actual DOM/page\n  // React manages something called the \"virtual DOM\" that it uses for optimizations\n  // React might recreate our components and modify this virtual DOM more or less times\n  // than we expect as it optimizes.  What this means is that the constructor, and any\n  // of our functions that use the virtual DOM should HAVE NO SIDE EFFECTS.\n\n  // The shorter punchline is, only send HTTP requests in two special methods on your components:\n  // componentDidMount() and componentDidUpdate()\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      swapiResponse: 'pending...',\n      userid: 1,\n    }\n  }\n\n  async componentDidMount() {\n    //This runs after the component has added an element to the actual DOM for the first time.\n    // In other words, this runs once the component is done being created.\n    // Send requests here!\n    this.setState({\n      swapiResponse: await getPlanet(this.state.userid)\n    });\n  }\n\n  // Lets us explicitly compare new state and new props to the current state and props\n  // Then decide if we need to update or not.\n  // We can use this to make our app more efficient and fix update->setState->update loops\n  shouldComponentUpdate(nextProps: any, nextState: any) {\n    // If this returns true, the component will update.  If false, the component won't.\n    // should update if we have different response from SWAPI, otherwise no.\n    return this.state.swapiResponse !== nextState.swapiResponse;\n  }\n\n  async componentDidUpdate() {\n    //This runs when the component updates on the actual DOM\n    this.setState({\n      swapiResponse: await getPlanet(this.state.userid)\n    });\n  }\n\n  // We could send a request here too, that'd be OK.\n  incrementPlanetId = () => {\n    this.setState({\n      planetId: this.state.userid + 1\n    })\n  }\n\n  render() {\n    return (\n      <>\n      {/* Button that adds one to planetId */}\n      <button onClick={this.incrementPlanetId}>Next Planet</button>\n      {/* We needed the JSON.stringify to turn our planet object into a string */}\n      <p>Response from SWAPI for id {this.state.planetId}: {JSON.stringify(this.state.swapiResponse)}</p>\n      </>\n    );\n  }\n\n}"]},"metadata":{},"sourceType":"module"}